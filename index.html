<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PhnField</title>

<!-- MapLibre（Drawと相性のよい 2系） -->
<link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet">
<script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>

<!-- mapbox-gl-draw -->
<link href="https://unpkg.com/@mapbox/mapbox-gl-draw@1.4.3/dist/mapbox-gl-draw.css" rel="stylesheet">
<script src="https://unpkg.com/@mapbox/mapbox-gl-draw@1.4.3/dist/mapbox-gl-draw.js"></script>

<!-- Turf（円の生成/距離計算） -->
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

<!-- FlatGeobuf（ブラウザで .fgb 生成） -->
<script src="https://unpkg.com/flatgeobuf/dist/flatgeobuf-geojson.min.js"></script>

<!-- Yjs + y-webrtc（P2P同期・サーバ不要）。読めない場合は自動でローカルモードへ -->
<script src="https://unpkg.com/yjs@13.6.18/dist/yjs.js"></script>
<script src="https://unpkg.com/y-webrtc@10.6.9/dist/y-webrtc.min.js"></script>

<style>
  html, body, #map { height:100%; margin:0; padding:0; }
  .toolbar{
    position:absolute; top:60px; left:10px; z-index:999;
    background:#fff; padding:10px; border-radius:8px;
    box-shadow:0 2px 8px rgba(0,0,0,.15);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  .toolbar strong{ display:block; margin-bottom:6px; }
  .toolbar .small{ font-size:12px; color:#555; margin-bottom:8px; }
  .toolbar button{
    display:block; width:210px; margin:5px 0; padding:10px;
    font-size:15px; border:1px solid #ccc; border-radius:6px; background:#f8f8f8;
  }
  .toolbar button:hover{ background:#eee; }
  .comment-label{
    background: rgba(255,255,255,0.75);
    border-radius:4px; padding:2px 6px; font-size:12px; pointer-events:none;
  }
</style>
</head>
<body>
<div id="map"></div>

<div class="toolbar">
  <strong>PhnField</strong>
  <div id="status" class="small">起動中…</div>

  <!-- 描画モード -->
  <button id="btn-select">選択/移動モード</button>
  <button id="btn-point">点モード</button>
  <button id="btn-line">線モード</button>
  <button id="btn-polygon">ポリゴンモード</button>
  <button id="btn-arrow">矢印モード</button>
  <button id="btn-circle">円モード</button>
  <button id="btn-trash">選択を削除</button>

  <hr>

  <!-- 操作 -->
  <button id="btn-save-geojson">GeoJSONで保存</button>
  <button id="btn-save-fgb">FlatGeobufで保存</button>
  <button id="btn-clear">全削除</button>
  <button id="btn-toggle-labels">コメント表示 切替</button>
  <button id="btn-toggle-basemap">地図切替（OSM⇄GSI）</button>
</div>

<script>
(function(){
  const $ = (id)=>document.getElementById(id);
  const setStatus = (s)=>{ const el=$('status'); if(el) el.textContent=s; };

  const roomName = new URLSearchParams(location.search).get("room") || "default";

  /* ===================== ベースマップ（OSM/GSIを同時に読み込み → レイヤ可視切替） ===================== */
  const map = new maplibregl.Map({
    container: 'map',
    style: {
      "version": 8,
      "sources": {
        "osm": {
          "type": "raster",
          "tiles": ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
          "tileSize": 256,
          "attribution": "© OpenStreetMap contributors"
        },
        "gsi": {
          "type": "raster",
          "tiles": ["https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png"],
          "tileSize": 256,
          "attribution": "地理院タイル（<a href='https://maps.gsi.go.jp/development/ichiran.html' target='_blank' rel='noopener'>出典</a>）"
        }
      },
      "layers": [
        { "id": "basemap-gsi", "type": "raster", "source": "gsi", "layout": {"visibility":"visible"} },
        { "id": "basemap-osm", "type": "raster", "source": "osm", "layout": {"visibility":"none"} }
      ]
    },
    center: [135.8049, 34.6851], // 奈良
    zoom: 12,
    attributionControl: true
  });
  map.addControl(new maplibregl.NavigationControl(), 'top-right');
  map.addControl(new maplibregl.AttributionControl({compact:false}), 'bottom-right');
  let basemap = 'GSI';

  /* ===================== Draw ===================== */
  const Draw = new MapboxDraw({
    displayControlsDefault: false,
    defaultMode: 'simple_select'
  });
  map.addControl(Draw, 'top-left'); // 選択UIなどの表示に必要

  /* ===================== 矢印ヘッド画像を生成（Canvas） ===================== */
  function addArrowImageOnce() {
    if (map.hasImage('arrow-head')) return;
    const size = 64, cvs = document.createElement('canvas');
    cvs.width = cvs.height = size;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.moveTo(size*0.15, size*0.2);
    ctx.lineTo(size*0.85, size*0.5);
    ctx.lineTo(size*0.15, size*0.8);
    ctx.closePath();
    ctx.fill();
    map.addImage('arrow-head', cvs, { pixelRatio: 2 });
  }

  /* ===================== 矢印ポイント／円プレビュー用ソース＆レイヤ ===================== */
  function ensureOverlays() {
    if (!map.getSource('arrow-points')) {
      map.addSource('arrow-points', { type:'geojson', data:{type:'FeatureCollection',features:[]} });
      map.addLayer({
        id:'arrow-points-layer', type:'symbol', source:'arrow-points',
        layout:{
          'icon-image':'arrow-head',
          'icon-size': 0.5,
          'icon-rotate': ['get','bearing'],
          'icon-allow-overlap': true
        }
      });
    }
    if (!map.getSource('circle-preview')) {
      map.addSource('circle-preview', { type:'geojson', data:{type:'FeatureCollection',features:[]} });
      map.addLayer({
        id:'circle-preview-fill', type:'fill', source:'circle-preview',
        paint:{ 'fill-color':'#1e90ff', 'fill-opacity':0.15 }
      });
      map.addLayer({
        id:'circle-preview-line', type:'line', source:'circle-preview',
        paint:{ 'line-color':'#1e90ff', 'line-width':2, 'line-dasharray':[2,2] }
      });
    }
  }
  map.on('load', ()=>{ addArrowImageOnce(); ensureOverlays(); });

  /* ===================== コメントの吹き出し ===================== */
  let showLabels = true;
  function updateLabels() {
    document.querySelectorAll('.mapboxgl-marker').forEach(m => m.remove());
    if (!showLabels) return;
    const fs = Draw.getAll().features;
    fs.forEach(f => {
      const c = (f.properties && f.properties.comment) ? String(f.properties.comment) : '';
      if (!c) return;
      const el = document.createElement('div');
      el.className = 'comment-label';
      el.textContent = c;
      let lngLat;
      if (f.geometry.type === 'Point') lngLat = f.geometry.coordinates;
      else if (f.geometry.type === 'LineString') lngLat = f.geometry.coordinates[0];
      else lngLat = f.geometry.coordinates[0][0];
      new maplibregl.Marker({element:el}).setLngLat(lngLat).addTo(map);
    });
  }

  /* ===================== 矢印先端を更新 ===================== */
  function updateArrowHeads() {
    if (!map.getSource('arrow-points')) return;
    const pts = [];
    Draw.getAll().features.forEach(f=>{
      if (f.geometry.type==='LineString' && f.properties && f.properties.arrow===true) {
        const coords = f.geometry.coordinates;
        if (coords.length<2) return;
        const a = coords[coords.length-2], b = coords[coords.length-1];
        const bearing = turf.bearing(turf.point(a), turf.point(b));
        pts.push({ type:'Feature', geometry:{type:'Point', coordinates:b}, properties:{bearing} });
      }
    });
    map.getSource('arrow-points').setData({type:'FeatureCollection',features:pts});
  }

  /* ===================== P2Pリアルタイム（y-webrtc）／失敗時はローカルにフォールバック ===================== */
  let ydoc = null, provider = null, yfeatures = null, realtime = false;
  try {
    if (window.ywebrtc && window.Y) {
      ydoc = new Y.Doc();
      provider = new ywebrtc.WebrtcProvider("phnfield-"+roomName, ydoc, {
        signaling: ['wss://signaling.yjs.dev']
      });
      yfeatures = ydoc.getArray("features");
      yfeatures.observe(()=>{ // 受信 → 反映
        const arr = yfeatures.toArray();
        Draw.deleteAll();
        if (arr.length) Draw.add({type:'FeatureCollection', features:arr});
        updateLabels(); updateArrowHeads();
      });
      realtime = true;
      setStatus("リアルタイム同期：接続中（room=" + roomName + "）");
      provider.on('status', e=> setStatus("リアルタイム同期：" + e.status + "（room=" + roomName + "）"));
    } else {
      throw new Error("y-webrtc not loaded");
    }
  } catch(err){
    console.warn("P2P同期をローカルにフォールバック:", err);
    setStatus("ローカル編集（同期なし）");
  }

  function syncToY(){
    if (!realtime) return; // ローカル時は何もしない
    const arr = Draw.getAll().features;
    ydoc.transact(()=>{ yfeatures.delete(0, yfeatures.length); yfeatures.push(arr); });
  }

  /* ===================== 描画イベント（コメント入力・同期・ラベル・矢印） ===================== */
  function askCommentAndSave(id){
    const c = prompt("コメントを入力（任意）") || "";
    Draw.setFeatureProperty(id, 'comment', c);
    updateLabels(); updateArrowHeads(); syncToY();
  }
  map.on('draw.create', e=>{
    const f = e.features[0];
    // 矢印モード中なら flag
    if (arrowMode && f.geometry.type==='LineString') {
      Draw.setFeatureProperty(f.id, 'arrow', true);
      arrowMode = false;
    }
    askCommentAndSave(f.id);
  });
  map.on('draw.update', ()=>{ updateLabels(); updateArrowHeads(); syncToY(); });
  map.on('draw.delete', ()=>{ updateLabels(); updateArrowHeads(); syncToY(); });

  /* ===================== 円モード（中心→半径点） ===================== */
  let circleMode=false, circleCenter=null;
  function updateCirclePreview(center, cursor){
    if (!center) return;
    const r = turf.distance(turf.point(center), turf.point([cursor.lng, cursor.lat]), {units:'kilometers'})*1000;
    const poly = turf.circle(center, Math.max(r,1), {steps:64, units:'meters'});
    map.getSource('circle-preview').setData(poly);
  }
  map.on('mousemove', (e)=>{ if(circleMode && circleCenter){ updateCirclePreview(circleCenter, e.lngLat); } });

  map.on('click', (e)=>{
    if (!circleMode) return;
    if (!circleCenter){
      circleCenter = [e.lngLat.lng, e.lngLat.lat];
      updateCirclePreview(circleCenter, e.lngLat);
    } else {
      const r = turf.distance(turf.point(circleCenter), turf.point([e.lngLat.lng, e.lngLat.lat]), {units:'kilometers'})*1000;
      const poly = turf.circle(circleCenter, Math.max(r,1), {steps:64, units:'meters'});
      const id = Draw.add({ type:'Feature', geometry: poly.geometry, properties:{ shape:'circle', radius_m: Math.round(r) } });
      map.getSource('circle-preview').setData({type:'FeatureCollection',features:[]});
      circleMode=false; circleCenter=null; map.getCanvas().style.cursor='';
      askCommentAndSave(Array.isArray(id)?id[0]:id);
    }
  });

  /* ===================== 矢印モード・UIボタン等（確実にバインド） ===================== */
  let arrowMode=false;

  $('btn-select').onclick  = ()=> Draw.changeMode('simple_select');
  $('btn-point').onclick   = ()=> Draw.changeMode('draw_point');
  $('btn-line').onclick    = ()=> Draw.changeMode('draw_line_string');
  $('btn-polygon').onclick = ()=> Draw.changeMode('draw_polygon');
  $('btn-trash').onclick   = ()=> { Draw.trash(); updateLabels(); updateArrowHeads(); syncToY(); };

  $('btn-arrow').onclick = ()=>{
    arrowMode = true;
    Draw.changeMode('draw_line_string');
    setStatus((realtime?'リアルタイム同期':'ローカル編集')+'｜矢印モード：線を描くと自動で矢印化');
  };

  $('btn-circle').onclick = ()=>{
    circleMode=true; circleCenter=null; map.getCanvas().style.cursor='crosshair';
    alert('円モード：中心→半径の順に2回クリックで確定');
  };

  function download(name, blob){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob); a.download = name;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
  }
  $('btn-save-geojson').onclick = ()=>{
    const fc = Draw.getAll();
    download('phnfield.geojson', new Blob([JSON.stringify(fc, null, 2)], {type:'application/geo+json'}));
  };
  $('btn-save-fgb').onclick = ()=>{
    const fc = Draw.getAll();
    const bytes = flatgeobuf.geojson.serialize(fc);
    download('phnfield.fgb', new Blob([bytes], {type:'application/octet-stream'}));
  };
  $('btn-clear').onclick = ()=>{
    if (!confirm('全て削除しますか？')) return;
    Draw.deleteAll(); updateLabels(); updateArrowHeads(); syncToY();
  };
  $('btn-toggle-labels').onclick = ()=>{
    showLabels = !showLabels; updateLabels();
  };
  $('btn-toggle-basemap').onclick = ()=>{
    basemap = (basemap==='GSI')?'OSM':'GSI';
    map.setLayoutProperty('basemap-gsi', 'visibility', basemap==='GSI'?'visible':'none');
    map.setLayoutProperty('basemap-osm', 'visibility', basemap==='OSM'?'visible':'none');
  };

  // 初期表示
  setStatus(realtime ? `リアルタイム同期：接続中（room=${roomName}）` : 'ローカル編集（同期なし）');
})();
</script>
</body>
</html>
